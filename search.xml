<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Sinon.js 測試套件與測試替身（中）</title>
      <link href="/2018/05/24/testing/sinon-beginner-2/"/>
      <url>/2018/05/24/testing/sinon-beginner-2/</url>
      <content type="html"><![CDATA[<h1 id="接續Sinon-js-測試套件與測試替身（中）"><a href="#接續Sinon-js-測試套件與測試替身（中）" class="headerlink" title="接續Sinon.js 測試套件與測試替身（中）"></a>接續Sinon.js 測試套件與測試替身（中）</h1><p>此篇 <code>接續Sinon.js 測試套件與測試替身（上）</code></p><h4 id="Stub"><a href="#Stub" class="headerlink" title="Stub"></a>Stub</h4><p>可以避免某些功能被呼叫，像是 ajax call，並且能控制 function 走向特定流程（EX：拋出錯誤）</p><h4 id="sinon文件上的-anonymous-function-示範"><a href="#sinon文件上的-anonymous-function-示範" class="headerlink" title="sinon文件上的 anonymous function 示範"></a>sinon文件上的 anonymous function 示範</h4><p><strong>withArgs</strong></p><p>設定stub要帶入的參數，搭配其後續動作<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> callback = sinon.stub();</span><br><span class="line">callback.withArgs(<span class="number">42</span>).returns(<span class="number">1</span>);</span><br><span class="line">callback.withArgs(<span class="number">1</span>).throws(<span class="string">"name"</span>);</span><br><span class="line"></span><br><span class="line">callback(); <span class="comment">// No return value, no exception</span></span><br><span class="line">callback(<span class="number">42</span>); <span class="comment">// Returns 1</span></span><br><span class="line">callback(<span class="number">1</span>); <span class="comment">// Throws Error("name")</span></span><br></pre></td></tr></table></figure></p><p>透過 <code>withArgs</code> 設定傳入的參數，並且決定他要傳出的結果為 <code>1</code> 或是 <code>error case</code></p><p> <strong>onCall</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> callback = sinon.stub();</span><br><span class="line"> callback.onCall(<span class="number">0</span>).returns(<span class="number">1</span>);</span><br><span class="line"> callback.onCall(<span class="number">1</span>).returns(<span class="number">2</span>);</span><br><span class="line"> callback.returns(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"> callback(); <span class="comment">// Returns 1</span></span><br><span class="line"> callback(); <span class="comment">// Returns 2</span></span><br><span class="line"> callback(); <span class="comment">// All following calls return 3</span></span><br></pre></td></tr></table></figure></p><p>透過 <code>onCall</code> 設定 function 被 call 幾次後會有什麼回傳，像是第一次 call 回傳 1，第二次為2</p><h4 id="已存在函示示範"><a href="#已存在函示示範" class="headerlink" title="已存在函示示範"></a>已存在函示示範</h4><p><strong>yields</strong> <code>stub.yields([arg1, arg2, ...])</code></p><p>如果stub有收到callback參數，用yields會直接call第一個callback函式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var myfun = &#123;</span><br><span class="line">  fun1: function () &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function cb(data) &#123;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;</span><br><span class="line">sinon.stub(myfun, &quot;fun1&quot;).yields(&apos;callback arg1&apos;)</span><br><span class="line">myfun.fun1(cb) //印出&apos;callback arg1&apos;</span><br></pre></td></tr></table></figure><p>可以發現即使myfun裡的fun1沒有任何參數，還是可以通過，代表stub不會真的去call那個function</p><p><strong>yieldTo</strong> <code>stub.yieldsTo(property, [arg1, arg2, ...])</code></p><p>如果呼叫funtion時傳入一個object，可透過 <code>yeildsTo</code> 指定invoke某個function<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sinon.stub(myfun, <span class="string">"fun1"</span>).yieldsTo(<span class="string">'shit'</span>,<span class="string">'shit arg'</span>)</span><br><span class="line">myfun.fun1(&#123;<span class="attr">shit</span>:<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123; <span class="comment">//印出shit arg</span></span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>到這邊都只是在瞭解語法，那我們來阻止 ajax call 真正的發生吧！！<br><strong>來stub jQuery 的 ajax call</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sinon.stub(jQuery, <span class="string">"ajax"</span>).yieldsTo(<span class="string">"success"</span>, <span class="string">"ajax arg"</span>);</span><br><span class="line"></span><br><span class="line">    jQuery.ajax(&#123;</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//最後印出ajax arg</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我幾乎都用promise方式來接成功或失敗呀！那就使用usingPromise</p><p><strong>usingPromise</strong> <code>stub.usingPromise(promiseLibrary)`</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sinon.stub($,<span class="string">'ajax'</span>).usingPromise($.Deferred()).resolves(<span class="string">"baz"</span>)</span><br><span class="line">$.ajax(<span class="string">'123'</span>)</span><br><span class="line">  .done(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">//baz</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果測試要接上promise，首先我們必須知道它所使用的 Promise Library，查了一下 jQuery 才知道說原來他使用 defeered (使用.done連接）</p><p>只要使用jQuery.Deferred() 可以取得deferred object，所以就將它丟進usingPromise funtion 當參數</p><p>假如今天是使用預設的Promise，也就是使用 <code>.then</code> 串接，那<code>promiseLibrary</code>則要傳入 <code>Promise</code></p><p><strong>來把 .done 改成 .then</strong></p><pre><code class="JavaScript=">sinon.stub($,&apos;ajax&apos;).usingPromise(Promise).resolves(&quot;87&quot;)$.ajax(&apos;123&apos;) //印出87  .then(function (data) {    console.log(data);  })</code></pre>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Sinon.js 測試套件與測試替身（上）</title>
      <link href="/2018/05/22/testing/sinon-beginner-1/"/>
      <url>/2018/05/22/testing/sinon-beginner-1/</url>
      <content type="html"><![CDATA[<h1 id="Sinon-js-測試套件與測試替身（上）"><a href="#Sinon-js-測試套件與測試替身（上）" class="headerlink" title="Sinon.js 測試套件與測試替身（上）"></a>Sinon.js 測試套件與測試替身（上）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Sinon.js 是一套提供給JavaScipt使用的Testing Plugins，如果有先前有看過JavaScript 中的測試工具怎麼分類？文章，那你會大概瞭解測試套件在測試中扮演什麼角色</p><h2 id="Test-Doubles"><a href="#Test-Doubles" class="headerlink" title="Test Doubles"></a>Test Doubles</h2><p>首先必須先知道 − Test Double (測試替身），它可以在測試中代替那些會造成我們不便的 funciton</p><blockquote><p>Test Double類似於電影中一些危險動作，導演們會請專業替身代替影星們去執行這些事情。</p></blockquote><h3 id="Test-Doubles-目的"><a href="#Test-Doubles-目的" class="headerlink" title="Test Doubles 目的"></a>Test Doubles 目的</h3><h4 id="註"><a href="#註" class="headerlink" title="註"></a>註</h4><ul><li>SUT = System under test 你要測的東西</li><li>DOC = Depended On Component SUT 所依賴的東西(function or package)</li></ul><ol><li>讓我可以只測SUT而不必去管DOC狀況</li></ol><p>例如：前端接完 API 後的畫面邏輯已經寫好了並想要測試它，可是瑞凡你後端的 API 還沒開好，這時 ajax 發出的 request 就可以使用 Test Doubles 跳過去</p><ol start="2"><li>模擬狀況</li></ol><p>可以控制流程的走向，像Call 登入 API 的時候，讓他走到Error Case</p><ol start="3"><li>加速開發，不用等其他人</li></ol><h3 id="Test-Doubles種類"><a href="#Test-Doubles種類" class="headerlink" title="Test Doubles種類"></a>Test Doubles種類</h3><ol><li>Spy</li><li>Stub</li><li>Mock</li><li>Fake</li><li>Dummy</li></ol><p>Sinon.js提供 Spy, Stub, Mock, Fake四種實作方式，因此Dummy不另外介紹</p><h3 id="Spy"><a href="#Spy" class="headerlink" title="Spy"></a>Spy</h3><p>spy是間諜的意思，如字面上它可以監測某個function，並取得她的資訊，像是：function被call了幾次、被call的時候帶了哪些參數、回傳值是什麼……等</p><p>使用 sinon 的 anonymous function 示範<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> spy = sinon.spy()</span><br><span class="line">spy(<span class="string">'a'</span>,<span class="string">'b'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(spy.firstCall.args) <span class="comment">//['a', 'b']</span></span><br></pre></td></tr></table></figure></p><p>第四行看到使用<code>spy.firstCall.args</code>可取得function被呼叫時所帶入的參數</p><p>接著換作一個已存在的函式 isExpire 作為範例</p><p>註：isExpire用來判斷傳入的參數是否過期<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> product = &#123;</span><br><span class="line">    isExpire:<span class="function"><span class="keyword">function</span>(<span class="params">expireDate</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> now = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()</span><br><span class="line">        <span class="keyword">let</span> expire = <span class="built_in">Date</span>.parse(expireDate)</span><br><span class="line">        <span class="keyword">return</span> (now &gt; expire) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> spy = sinon.spy(product,<span class="string">'isExpire'</span>)</span><br><span class="line">product.isExpire(<span class="string">'1995/2/3'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(spy.calledOnce) <span class="comment">//結果為1</span></span><br></pre></td></tr></table></figure></p><p>11行指定要 spy product 上的 isExpire function，在確認其呼叫次數為1</p>]]></content>
      
      
        <tags>
            
            <tag> testing </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker－Image篇</title>
      <link href="/2018/05/21/docker/docker-image/"/>
      <url>/2018/05/21/docker/docker-image/</url>
      <content type="html"><![CDATA[<h1 id="Docker－Image篇"><a href="#Docker－Image篇" class="headerlink" title="Docker－Image篇"></a>Docker－Image篇</h1><h2 id="image（映像檔）"><a href="#image（映像檔）" class="headerlink" title="image（映像檔）"></a>image（映像檔）</h2><p>docker 的唯獨模板，例如：一個映像檔可以包涵完整的 ubuntu系統，就叫他 ubuntu映像檔，當然這個映像檔也可以裝上 apache，以及其他東西，就被稱作ＸＸＸ映像檔。</p><h2 id="取得映像檔"><a href="#取得映像檔" class="headerlink" title="取得映像檔"></a>取得映像檔</h2><p>可使用 docker pull 指令下載某個倉庫的映像檔，若沒有指定tag，則會預設使用 latest標籤（最新）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// latest</span><br><span class="line">docker pull ubuntu</span><br><span class="line">// 14 version</span><br><span class="line">docker pull ubuntu:14.04</span><br></pre></td></tr></table></figure><p>事實上都是從預設的註冊伺服器下載（docker hub），相當於</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry.hub.docker.com/ubuntu:XXX</span><br></pre></td></tr></table></figure><p>當然也可以從其他register抓取資源，像是docker pool。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull dl.dockerpool.com:5000/ubuntu</span><br></pre></td></tr></table></figure><p>下載好後即可利用這個image 建出container(實例），並且執行bash</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -i ubuntu /bin/bash</span><br></pre></td></tr></table></figure><h2 id="查看映像檔"><a href="#查看映像檔" class="headerlink" title="查看映像檔"></a>查看映像檔</h2><p>使用 <code>docker images</code> 查看本機上已存在的映像檔</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/usGN02N.png" alt=""></p><p>TAG 資訊用於標記來自同一個倉庫（ubuntu) 不同的映像檔， docker tag 則可為本機上映像檔添增新標籤 (repository欄位名稱），這兩者不一樣。</p><p>docker tag 產生的新映像檔實際上指向了同一個映像檔，所以他們 IMAGE ID 相同</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag ubuntu:latest xxxx</span><br><span class="line">docker tag &lt;ID&gt; xxxx</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/LtVv2RY.png" alt=""></p><p>若要查看映像檔詳細資訊可使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker inspect &lt;ID&gt;</span><br><span class="line">//可使用-f查詢特定參數</span><br><span class="line">docker inspect -f &#123;&#123;".Architecture"&#125;&#125; &lt;ID&gt;</span><br></pre></td></tr></table></figure><h2 id="搜尋映像檔"><a href="#搜尋映像檔" class="headerlink" title="搜尋映像檔"></a>搜尋映像檔</h2><p>使用 docker search <key term=""> 搜尋遠端倉庫中的映像檔，預設搜尋 Docker Hub</key></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure><h2 id="刪除映像檔"><a href="#刪除映像檔" class="headerlink" title="刪除映像檔"></a>刪除映像檔</h2><p>使用 docker rmi <id or="" tag=""> 刪除映像檔</id></p><p>使用 tag 刪除: 假設有多個 Tag 指向同個 ID，則刪除某個 image（使用 docker images 看到的 image) 時不會真的刪掉真實的 image，只是刪除他的標籤。如果最後只剩一個，則真實 image就會被刪除。</p><p>使用 ID 刪除:如果有多個 tag 指到同個 ID (使用 docker tag)，則無法刪除必須使用 tag，它不會讓你直接刪除真實 image，除非只剩一個 tag 指到 image ID</p><h2 id="建立映像檔"><a href="#建立映像檔" class="headerlink" title="建立映像檔"></a>建立映像檔</h2><ul><li>基於現有映像檔的容器建立</li></ul><p>啟動一個本來就有的映像檔，然後在上面進行修改並新增一個檔後退出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti ubuntu /bin/bash</span><br><span class="line">docker commit -m "xxxxx" -a "xxxx" &lt;container ID&gt; &lt;tag Name&gt;</span><br><span class="line">ex:</span><br><span class="line">docker commit -m "added a new file" -a "docker newbee" a925cb40b3fo test</span><br></pre></td></tr></table></figure><p>此時使用docker images就會發現有新的image</p><ul><li>基於Linux 容器（LXC）範例匯入</li></ul><p>有空補上</p><ul><li>Dockerfile</li></ul><p>有空補上</p><h2 id="儲存和載入映像檔"><a href="#儲存和載入映像檔" class="headerlink" title="儲存和載入映像檔"></a>儲存和載入映像檔</h2><p>如果要將image存成壓縮檔可使用docker save</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker save -o ubuntu_latest.tar ubuntu</span><br><span class="line">//這比較常見</span><br><span class="line">docker save ubuntu &gt; xxx.tar</span><br></pre></td></tr></table></figure><p>反之則可使用docker load把壓縮檔載入本機映像檔</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; xxx.tar</span><br></pre></td></tr></table></figure><h2 id="上傳映像檔"><a href="#上傳映像檔" class="headerlink" title="上傳映像檔"></a>上傳映像檔</h2><p>首先，你必須先去 Docker Hub 辦帳號，並且創一個 repo 取名為 uploadtest (隨意)，接著可以使用 docker push 上傳(根本就 github)。</p><p>以下需注意，假設 tag 為 ubuntu，則需要先用 docker tag 將其新增一個 tag，名稱必須是 Docker Hub ID/Docker hub上 repo<br>name，在使用push就可直接推到遠端。記得要先用docker login登入，不然就耍智障了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. docker login</span><br><span class="line">//curt6815463是我docker hub上ID, uploadtest是我在上面創的repo名字</span><br><span class="line">2. docker tag ubuntu curt6815463/uploadtest</span><br><span class="line">3. docker push curt6815463/uploadtest</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript中的測試工具怎麼分類？</title>
      <link href="/2018/05/20/testing/testing-classify/"/>
      <url>/2018/05/20/testing/testing-classify/</url>
      <content type="html"><![CDATA[<h1 id="測試的工具怎麼分類？"><a href="#測試的工具怎麼分類？" class="headerlink" title="測試的工具怎麼分類？"></a>測試的工具怎麼分類？</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>開始練習寫測試的時候，再學會語法之前常常就被一堆的工具搞混，像是Jest、Mocha、Karma……等，這篇文章來簡單聊聊這些工具的功用及分類</p><h2 id="隨意說說Unit-Test"><a href="#隨意說說Unit-Test" class="headerlink" title="隨意說說Unit Test"></a>隨意說說Unit Test</h2><blockquote><p>單元測試專注在單一區塊程式碼，可能是function、Object、Module，在JS中主要以function為主，透過傳入的參數或設定外部變數來確認這個function的回傳為預期的結果</p></blockquote><p>舉個例子：假如今天在電商網站中，實作一個確認商品沒有過期的Function</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isExpire</span>(<span class="params">expireDate</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> now = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()</span><br><span class="line">  <span class="keyword">let</span> expire = <span class="built_in">Date</span>.parse(expireDate)</span><br><span class="line">  <span class="keyword">return</span> (now &gt; expire) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>當傳入的expireDate參數比今天日期小時，代表商品已經過期必須要回傳false，因此測試可能寫成這樣</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isExpire(<span class="string">'3000/4/4'</span>))&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'OK pass'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">'expire function error'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是這樣寫不但需要自己管理測試程式，呈現的結果也很糟糕，這時候就可以使用一些測試工具摟</p><!-- 補充：除了Unit Test，還有End-To-Ent Testing呢！！ --><h2 id="工具分類"><a href="#工具分類" class="headerlink" title="工具分類"></a>工具分類</h2><p>測試工具通常可以分為四類，這不是絕對！不過可以思考這樣分類的意義</p><ol><li>Test Runner</li><li>Testing Framework</li><li>Assertion Libraries</li><li>Testing Plugins</li></ol><h3 id="Test-Runner"><a href="#Test-Runner" class="headerlink" title="Test Runner"></a>Test Runner</h3><p>提供環境給測試工具在其中運行，並且將處理結果輸出到Log、File、Console……等</p><p>Karma是個標準的Test Runner，他會產生一個網頁伺服器，針對不同瀏覽器跑你寫的Unit Test，並將結果輸出到console，告訴你哪些測試是pass哪些是fail</p><p>當你要測的程式碼<code>本身需要跑在瀏覽器時</code>，像是操作網頁的DOM或是測試一些前端framework的畫面邏輯，你就可以使用<code>Karma</code>，因為通常Unit Test會寫在.js檔並用Node.js去跑，而Node.js只是一個跑在伺服器端環境的JavaScript，所以想要在伺服器端運行瀏覽器端的程式碼就得靠它了</p><p>註：這邊指的伺服器端只是代表<code>他沒有在browser端</code>，並不是一定要開個Http Server才能寫Node.js</p><h3 id="Testing-Framework"><a href="#Testing-Framework" class="headerlink" title="Testing Framework"></a>Testing Framework</h3><p>提供一個寫測試的規則，讓你照著那個準則就可以很方便的撰寫及管理測試程式碼（根本只是在講framwork是什麼東西吧），那我們來舉個實例</p><p>如果使用了mocha剛剛的範例就會如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'isExpier'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'check the date whether is expier'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (isExpier(<span class="string">"2000/04/04"</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'the date should be expire'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以看到多了describe及it，這就是mocha提供的規則，讓我們能比較方便對Unit Test 進行分類，對於Test Runner執行後的結果也能整理成漂亮的報表來呈現</p><p>但是依舊要寫If-Else好煩啊！！還要寫那麼長，這時候Assertion Libraries（斷言庫）就可以派上用場拉！</p><h3 id="Assertion-Libraries"><a href="#Assertion-Libraries" class="headerlink" title="Assertion Libraries"></a>Assertion Libraries</h3><p>斷言可以替Unit Test省下冗長的If-Else，除此之外還可以增加程式碼的可讀性</p><p>我們使用Chai再將剛剛的例子修改一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'isExpire'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'check the date whether is expier'</span>, () =&gt; &#123;</span><br><span class="line">    expect(isExpire(<span class="string">'2000/04/04'</span>).to.equal(<span class="literal">false</span>))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>是不是就簡單多了？</p><p>註：斷言寫法有分為TDD style, BDD style，上面範例為BDD style，這又可追溯到開發原理TDD與BDD，不過本篇暫時不討論</p><h3 id="Testing-Plugins"><a href="#Testing-Plugins" class="headerlink" title="Testing Plugins"></a>Testing Plugins</h3><p>基本上使用Test Runner、Test Framework、Assertion Libaraies就可以寫好測試了，不過試想有時為了測試某個功能，而特地開了API、Server、Database……等，是不是太麻煩了？或是為了測試異步的function，而使得測試過程為了等待回應而降低了測試的效益，像是Ajax Call，這時就可以使用一些Plugins，來幫助我們解決類似問題。</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><ul><li>Karma是Test Runner</li><li>Mocha是Testing Framework</li><li>Chai是Assertion Libaraies</li><li>Sinon主要是Testing Plugins，並自帶Aserrtion Libaraies</li><li>Jest主要是Testing Framework，並且有Assertion Libaraies + Testing Plugins<blockquote><p>Jest好棒棒</p></blockquote></li></ul><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="http://amzotti.github.io/testing/2015/03/16/what-is-the-difference-between-a-test-runner-testing-framework-assertion-library-and-a-testing-plugin/" target="_blank" rel="noopener">http://amzotti.github.io/testing/2015/03/16/what-is-the-difference-between-a-test-runner-testing-framework-assertion-library-and-a-testing-plugin/</a></p><p>本篇文章的工具四種分類為參考amzotti想法，並加上自己的觀點</p>]]></content>
      
      
        <tags>
            
            <tag> testing </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>設定overflow後scroll時，不能平滑滾動的問題怎麽處理？</title>
      <link href="/2018/05/20/mix/overflow-not-scroll-smooth/"/>
      <url>/2018/05/20/mix/overflow-not-scroll-smooth/</url>
      <content type="html"><![CDATA[<h1 id="overflow-scroll-時不能平滑滾動的問題怎麽處理？"><a href="#overflow-scroll-時不能平滑滾動的問題怎麽處理？" class="headerlink" title="overflow: scroll 時不能平滑滾動的問題怎麽處理？"></a>overflow: scroll 時不能平滑滾動的問題怎麽處理？</h1><h2 id="情境"><a href="#情境" class="headerlink" title="情境"></a>情境</h2><blockquote><p>在div設定 overflow:scroll後，從IOS手機打開瀏覽器會發現，滾動畫面的時候很卡，手一離開畫面就立即停止繼續滑動</p></blockquote><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>使用<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-overflow-scrolling</span>: <span class="selector-tag">touch</span>;</span><br></pre></td></tr></table></figure></p><p>這行會讓IOS啟動硬件加速，因此可解決卡頓的問題<br>不過這也是WebKit 108400版本左右才支持<br>因此iOS Safari需要5.0以上，Android4.0以上才有效</p><h2 id="探討前綴字元"><a href="#探討前綴字元" class="headerlink" title="探討前綴字元"></a>探討前綴字元</h2><h4 id="首先要知道不同的瀏覽器，會使用不同的引擎去實作"><a href="#首先要知道不同的瀏覽器，會使用不同的引擎去實作" class="headerlink" title="首先要知道不同的瀏覽器，會使用不同的引擎去實作"></a>首先要知道不同的瀏覽器，會使用不同的引擎去實作</h4><ul><li>OperaGoogle、Safari：Webkit</li><li>Firefox：Gecko</li></ul><p>註：<br>Opera以前是Presto後來改為Webkit<br>Firefox在mobile中也有部分使用Webkit實作</p><h4 id="因此在某些情況，瀏覽器會選擇使用前綴字眼表示某些CSS"><a href="#因此在某些情況，瀏覽器會選擇使用前綴字眼表示某些CSS" class="headerlink" title="因此在某些情況，瀏覽器會選擇使用前綴字眼表示某些CSS"></a>因此在某些情況，瀏覽器會選擇使用前綴字眼表示某些CSS</h4><h4 id="EX"><a href="#EX" class="headerlink" title="EX:"></a>EX:</h4><ol><li>試驗一些還未成為標準的的CSS屬性——也許永遠不會成為標準</li><li>對新出現的標準的CSS3屬性特徵做實驗性的實現</li><li>對CSS3中一些新屬性做等效語義的個性實現</li></ol><blockquote><p>主要就是讓瀏覽器來測試或試驗新的CSS標準</p></blockquote><h4 id="前綴字眼"><a href="#前綴字眼" class="headerlink" title="前綴字眼"></a>前綴字眼</h4><ol><li>-ms-：Trident（IE）</li><li>-moz-：Gecko(Firefox)</li><li>-o-：Presto(Opera)</li><li>-webkit-：Webkit(Chrome、Safari)</li></ol><h2 id="談談Web-open-in-mobile-app"><a href="#談談Web-open-in-mobile-app" class="headerlink" title="談談Web open in mobile app"></a>談談Web open in mobile app</h2><blockquote><p>常常開發的網頁在Line或Messenger，甚至是其他應用程式中打開居然就壞了！！明明自己寫跟測試的時候都正常啊？</p></blockquote><p>首先我們要理解，在手機應用程式內開啟的瀏覽器，與我們一般打開的browser有所出入，事實上俗稱<strong>Webview</strong>（以Chrome、Safari為主）</p><h3 id="Webview-In-App-Web"><a href="#Webview-In-App-Web" class="headerlink" title="Webview (In App Web)"></a>Webview (In App Web)</h3><p>根據Webkit引擎實作的手機內核瀏覽器，只是為了簡單的展示網頁，因此有些功能很可能沒有實作上去，像是Webview所打開的Safari就沒有cookie功能</p><h2 id="回到源頭：萬一這些In-app-web沒有實作這些CSS？"><a href="#回到源頭：萬一這些In-app-web沒有實作這些CSS？" class="headerlink" title="回到源頭：萬一這些In app web沒有實作這些CSS？"></a>回到源頭：萬一這些In app web沒有實作這些CSS？</h2><p>這時或許只好從JS的角度來解決問題</p><p>以這次的範例來思考，是不是可以再滾動的末尾在偷偷給加上一些數值？讓他假裝滑順（先不考慮它的加速度狀況）</p><p>首先我會直覺想到Dom的<strong>scroll event</strong>、<strong>wheel event</strong><br>註：scroll偵測scrollbar的變動，wheel偵測滑鼠滾輪滾動</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;wrap&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;...&lt;/li&gt;</span><br><span class="line">        ....無限多</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> el = <span class="built_in">document</span>.querySelector(<span class="string">'#wrap'</span>)</span><br><span class="line">el.addEventListener(<span class="string">'scroll'</span>,(event)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'正在scroll'</span>);  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以偵測到每次地滾動，不過我要的應該是最後一個scroll的事件而不是每一個都給它加上數值，可以使用<strong>setTimeout</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> el = <span class="built_in">document</span>.querySelector(<span class="string">'#wrap'</span>)</span><br><span class="line"><span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">el.addEventListener(<span class="string">'scroll'</span>,(event) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(timer !== <span class="literal">null</span>) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'這次scroll最後一個event'</span>);</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是做到這開始思考，大部分容易出這個狀況的應該是在mobile，那麼滑螢幕滾動時有按下去的瞬間以及釋放的瞬間，是不是使用<strong>touch event</strong>更加合適？</p><h3 id="touch-event"><a href="#touch-event" class="headerlink" title="touch event"></a>touch event</h3><p>共有四組</p><ul><li>touchstart</li><li>touchend</li><li>touchcancel</li><li>touchmove</li></ul><p>目前狀況看起來可使用touchend事件，來讓滑動的最後加上一些數值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> el = <span class="built_in">document</span>.querySelector(<span class="string">'#wrap'</span>)</span><br><span class="line">el.addEventListener(<span class="string">'touchend'</span>,(event)=&gt;&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        el.scrollTop = el.scrollTop + <span class="number">20</span></span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>當手離開時（touchend），把scrollTop偷偷加20模擬smooth的感覺<br>不過這樣會頓一下，因為是直接加上20所以會直接跳到那個位置<br>如果要有點smooth的feel我們可以用setInterval</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> el = <span class="built_in">document</span>.querySelector(<span class="string">'#wrap'</span>)</span><br><span class="line">el.addEventListener(<span class="string">'touchend'</span>,(event)=&gt;&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> final = el.scrollTop + <span class="number">20</span></span><br><span class="line">      scrollInterval = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (el.scrollTop &lt; final) &#123;</span><br><span class="line">        el.scrollTop = el.scrollTop + <span class="number">5</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> clearInterval(scrollInterval);</span><br><span class="line">      &#125;,<span class="number">15</span>);</span><br><span class="line">    &#125;,<span class="number">100</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>當手離開時，每0.015秒scrollTop加上5直到加滿20<br>這樣下來就稍微有模擬smooth的樣子<br>當然了，如果要讓它非常的滑順，則需要有良好計算及演算</p><p>PS:若想要使用手機debug，除了Chrome Dev Tool之外可使用<br><a href="https://console.re/" target="_blank" rel="noopener">https://console.re/</a></p>]]></content>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>為什麼vue可以寫在.vue檔裡面？</title>
      <link href="/2018/05/19/vue/why-vue-loader/"/>
      <url>/2018/05/19/vue/why-vue-loader/</url>
      <content type="html"><![CDATA[<h1 id="為什麼vue可以寫在-vue檔裡面？"><a href="#為什麼vue可以寫在-vue檔裡面？" class="headerlink" title="為什麼vue可以寫在.vue檔裡面？"></a>為什麼vue可以寫在.vue檔裡面？</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>想要寫一個vue應用你可以引入他的CDN，接著new出一個vue instance並開始寫裡面的邏輯，但除此之外Vue提供了別的方式來撰寫，那就是<code>vue-loader</code></p><h3 id="沒有使用vue-loader範例"><a href="#沒有使用vue-loader範例" class="headerlink" title="沒有使用vue-loader範例"></a>沒有使用vue-loader範例</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/vue/dist/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"counter"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">vue-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">vue-button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    Vue.component(<span class="string">'vue-button'</span>, &#123;</span></span><br><span class="line"><span class="undefined">      template: `</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="undefined">          &#123;&#123;count&#125;&#125;</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">'increment'</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="undefined">      `,</span></span><br><span class="line"><span class="javascript">      data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="undefined">          count: 0</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="undefined">      methods: &#123;</span></span><br><span class="line"><span class="javascript">        increment: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.count += <span class="number">1</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">'#counter'</span></span></span><br><span class="line"><span class="undefined">   &#125;)</span></span><br><span class="line"><span class="undefined"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="畫面效果"><a href="#畫面效果" class="headerlink" title="畫面效果"></a>畫面效果</h3><p><img src="https://i.imgur.com/tyjfMlA.png" alt=""></p><h3 id="問題點"><a href="#問題點" class="headerlink" title="問題點"></a>問題點</h3><p>當今天畫面邏輯變大時候，肯定要拆分不同的檔案不可能全部都寫在<code>html</code>裡面<br>而在html裡面我們也只能透過script tag引入不同js file來拆分檔案<br>如果有個方式來幫我們處理<code>分檔問題</code>是再好不過</p><h2 id="來使用vue-loader吧！！"><a href="#來使用vue-loader吧！！" class="headerlink" title="來使用vue-loader吧！！"></a>來使用vue-loader吧！！</h2><h3 id="使用概念"><a href="#使用概念" class="headerlink" title="使用概念"></a>使用概念</h3><p>將<code>Vue</code>程式直接寫在副檔名為.vue的file裡面，可是這些file始終要放到瀏覽器執行，因此需要有人幫他轉譯成.js檔案，那就是使用Webpack配上vue-loader</p><p>Webpack是一個前端打包工具，可以將各種資源通過一些規則（loader)，將其都打包成.js(或是.css .jpg……)，像是：</p><ul><li>sass-loader把.scss編譯成css</li><li>json-loader把 .json編譯成js (Webpack 二版後可以直接使用import引入json file)</li><li>vue-loader把.vue編譯成js</li></ul><p>題外話：webpack本身會解析ES6 module，將import關鍵字包裝成立即執行函數，裡面就放著要import的file程式碼</p><p>事實上這些設定是比較困難也複雜的，最快的方法可以透過<code>vue-cli</code>來產生vue project的模板，裡面已經幫我們做好vue-loader的配置</p><h3 id="vue-cli指令"><a href="#vue-cli指令" class="headerlink" title="vue-cli指令"></a>vue-cli指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 安裝全域vue-cli</span><br><span class="line"><span class="meta">$</span> npm install -g vue-cli</span><br><span class="line"></span><br><span class="line">// 初始化vue project</span><br><span class="line">// 格式：vue init &lt;template-name&gt; &lt;project-name&gt;</span><br><span class="line"><span class="meta">$</span> vue init webpack my-project</span><br></pre></td></tr></table></figure><p>進入my-project資料夾內的build/webpack.base.conf.js可以看到vue-loader的設定<br><img src="https://i.imgur.com/b8FfO9L.png" alt=""></p><h3 id="vue-loader-file說明"><a href="#vue-loader-file說明" class="headerlink" title="vue-loader file說明"></a>vue-loader file說明</h3><p>根據vue-loader官方文件說明，一個.vue檔基本上由<code>template</code>,<code>script</code>,<code>style</code>三個部份組成</p><ol><li><strong>template</strong>: 撰寫html以及渲染的邏輯指令，ex:v-show,v-model</li><li><strong>css</strong>: 可直接寫入html的css樣式(若再tag中加入scoped，則代表只有當前的.vue檔會生效)</li><li><strong>script</strong>：使用exprot default輸出這個component，意思就是說一個.vue檔可把他當作一個component</li></ol><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//這是test.vue檔</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"example"</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">    data () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">            msg: <span class="string">'Hello world!'</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.example</span> &#123;</span></span><br><span class="line"><span class="undefined">    color: red;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="不同Vue-file間引入"><a href="#不同Vue-file間引入" class="headerlink" title="不同Vue file間引入"></a>不同Vue file間引入</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"example"</span>&gt;</span>&#123;&#123; msg &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">xxx</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xxx</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> xxx <span class="keyword">from</span> xxx.vue</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">    components:&#123;</span></span><br><span class="line"><span class="undefined">        xxx</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    data () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">            msg: <span class="string">'Hello world!'</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.example</span> &#123;</span></span><br><span class="line"><span class="undefined">    color: red;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>使用import引入xxx.vue file（9行</li><li>並且在template中使用xxx組件（3 4行</li><li>注意！！記得要在components中掛上xxx（11行</li></ul>]]></content>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
